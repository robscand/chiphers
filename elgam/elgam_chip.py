#!/usr/bin/python3
# -*- coding: utf-8 -*-

# --- 1. Генерируется случайное простое число p. ---
# Функция определения простого числа - число делится на само себя и единицу
def isPrime(num):
    # перебираем возможные делители от 2 до числа, не превосходящего корня из искомого
    # Eсли число M имеет делитель pi, то имеется делитель qi, такой, что pi * qi = M.
    # То есть, чтобы найти пару, достаточно найти меньшее.
    # Среди всех пар, предполагаемая пара с максимальным наименьшим — это пара с равными pi и qi,
    # то есть pi * pi = M => pi = sqrt(M).
    for i in range(2, int(num ** 0.5) + 1):
        # если разделилось нацело, то составное
        if (num % i == 0):
            return False
    # если нет других делителей, то простое
    return True


# Функция случайным образом выбирает простое число из диапазона [50;150)
def getPrime():
    # Инициализируем границы диапазона
    min_prime, max_prime = 50, 150  # слишком маленький диапазон не подходит, возникают "шумы"
    # Инициализируем список простых чисел
    cached_primes = []
    # Сохраняем простые числа в список
    cached_primes = [i for i in range(min_prime, max_prime) if isPrime(i) == True]
    # выбираем случайным образом простое число из списка
    import random
    res = random.choice([i for i in cached_primes])  # [i for i in cached_primes if p<i<q]
    return res


# --- 2. Выбирается произвольное целое число g, являющееся первообразным (примитивным) корнем по модулю p. ---
# Пусть p=17. Берем число 2. Вопрос - это первобразный по модулю 17 или нет.
# Для этого достаточно проверить, что числа (2^2)-1, (2^4)-1, (2^8)-1 не делятся на 17.
# (2, 4 и 8 являются делителями числа 17-1=16) Здесь 2^8-1=17*15. Значит 2 не является первооборазным по модулю 17.
# Тогда берем 3 и те же степени: (3^2)-1, (3^4)-1, (3^8)-1 не делятся на 17, значит 3 - первообразный корень по модулю 17.

# Функция возвращает делители числа
def getDiv(num):
    return [i for i in range(2, num) if (num % i == 0)]



# Функция возвращает первообразный корень по модулю p
def getPrimitive(p):
    # определяем значение функции Эйлера для простого числа p
    fi = p - 1
    # находим делители числа p - 1
    divs = getDiv(fi)
    # Инициализируем список первообразных корней
    cached_primitives = []
    # осуществляем перебор чисел - потенциальных первообразных корней - от 2 до p-1 невключительно
    for i in range(2, fi):
        # осуществляем перебор делителей
        for d in divs:
            # Инициализируем список результатов расчета для числа i
            vals = []
            # возводим числа i в степень на делитель и вычитаем из результата 1, получившееся делим на модуль
            val = ((i ** d) - 1) % p
            # добавляем расчет в список результатов
            vals.append(val)
        # если для всех расчетов имеем остаток, то число i является первообразным корнем по модулю
        if 0 not in vals:
            # Сохраняем первообразные корни в списке
            cached_primitives.append(i)
    # выбираем случайным образом первообразный корень из списка
    import random
    res = random.choice([i for i in cached_primitives])
    return res


# --- 3. Выбирается случайное число x из интервала (1,p), взаимно простое с p-1. ---
# Натуральные числа a и b называют взаимно простыми, если их наибольший общий делитель равен 1
# Функция определения наибольшего общего делителя чисел a и b
def getNOD(a, b):
    rest = 1
    while rest != 0:
        rest = a % b
        a = b
        b = rest
    nod = a
    return nod


# Получить случайное число для закрытого ключа
def getX(p):
    # Инициализируем список числе, взаимнопростых с p-1 всех возможные числа от 1 до p-1 невключительно
    cached_x_nums = []
    # Cохраняем в список числа, для которых наибольший общий делитель с p-1 равняется единице
    cached_x_nums = [i for i in range(2, p) if getNOD(p - 1, i) == 1]
    # Выбираем случайным образом значение x из списка
    import random
    res = random.choice([i for i in cached_x_nums])
    return res


# --- 4. Вычисляется y = g**x(mod p). ---
# Функция для вычисления значения для открытого ключа
def getY(primitive, prime, private_k):
    return (primitive ** private_k) % prime


# Cоздаем русскоязычный алфавит
alph = ['а', 'б', 'в', 'г', 'д', 'е', 'ё', 'ж', 'з', 'и', 'й', 'к', 'л', 'м', 'н', 'о', 'п',
        'р', 'с', 'т', 'у', 'ф', 'х', 'ц', 'ч', 'ш', 'щ', 'ъ', 'ы', 'ь', 'э', 'ю', 'я', ' ',
        'А', 'Б', 'В', 'Г', 'Д', 'Е', 'Ё', 'Ж', 'З', 'И', 'Й', 'К', 'Л', 'М', 'Н', 'О', 'П',
        'Р', 'С', 'Т', 'У', 'Ф', 'Х', 'Ц', 'Ч', 'Ш', 'Щ', 'Ъ', 'Ы', 'Ь', 'Э', 'Ю', 'Я']


# При шифровании для каждого символа исходного сообщения нужно выполнить следующее
# --- 1. Выбирается случайное секретное число k из интервала (1, p-1), взаимно простое с p − 1. ---
# Функция генерации случайного секретного числа
def getK(p):
    # Инициализируем список числе, взаимнопростых с p-1 всех возможные числа от 1 до p-1 невключительно
    cached_k_nums = []
    # Cохраняем в список числа, для которых наибольший общий делитель с p-1 равняется единице
    cached_k_nums = [i for i in range(2, p - 1) if getNOD(p - 1, i) == 1]
    # Выбираем случайным образом значение k из списка
    import random
    res = random.choice([i for i in cached_k_nums])
    return res


# --- 2. Получаем шифротекст по формулам a = g**k(mod p), b = (y**k * T)(mod p)
# Функция для кодирования символа исходного сообщения
def symbElGamEncode(vsymb, k, public_key):
    # Пара чисел [a, b] является зашифрованным символом исходного сообшения
    # Вычисляем a
    a = (public_key[1] ** k) % public_key[2]
    # Вычисляем b
    b = ((public_key[0] ** k) * vsymb) % public_key[2]
    return [a, b]


# --- 3. Для расшифровки для каждой пары чисел зашифрованной последовательности
# нужно вычислить формулу t = b*(a**(p-1-x))(mod p)---
# Функция определения кода исходного символа по паре чисел [a, b] и закрытому ключу
def symbElGamDecode(pair, public_key, private_key):
    # вычисляем индекс символа в алфавите
    return (pair[1] * (pair[0] ** (public_key[2] - 1 - private_key))) % public_key[2]


# Функция генерации открытого и закрытого ключа
def elGamKeyGen():
    # Получаем случайное простое число p
    p = getPrime()
    # Получаем первообразный корень g по модулю p
    g = getPrimitive(p)
    # Получаем случайное число x для закрытого ключа
    x = getX(p)
    # Получаем значение y для открытого ключа
    y = getY(g, p, x)
    # Формируем набор значений для открытого ключа, обозначаем закрытый ключ
    public_key = [y, g, p]
    private_key = x
    return public_key, private_key


# Функция шифрования сообщения
def elGamEncode(inp_text, public_key):
    # Инициализируем словарь, в котором будет храниться зашифрованный текст
    crypt_dct = {}
    # Кодируем символы исходного сообщения
    for i in range(len(inp_text)):
        # Находим позицию символа исходного сообщения в алфавите
        vsymb = alph.index(inp_text[i])
        # Получаем секретное случайное число k
        k = getK(public_key[2])
        # Кодируем символ и сохраняем пару чисел [a,b] в словарь зашифрованного текста
        crypt_dct[i] = symbElGamEncode(vsymb, k, public_key)
    return crypt_dct


# Функция расшифровки сообщения
def elGamDecode(crypt_dct, public_key, private_key):
    # Расшифрованное сообщение
    decode_text = ''
    # Проходим по всем парам значений
    for key, val in crypt_dct.items():
        # Вычисляем позицию символа исходного сообщения в алфавите
        vsymb = symbElGamDecode(val, public_key, private_key)
        # Находим символ в алфавите и сохраняем
        decode_text += alph[vsymb]
    return decode_text
